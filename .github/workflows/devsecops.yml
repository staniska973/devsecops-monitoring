# ─── Nom du pipeline ──────────────────────────────────────────────────────────
# Ce nom s'affiche dans l'onglet "Actions" de GitHub.
name: DevSecOps Pipeline

# ─── Déclencheurs ─────────────────────────────────────────────────────────────
# On définit quand ce pipeline se lance automatiquement.
on:
  push:
    # Le pipeline se déclenche à chaque "git push" sur la branche "main".
    branches: [main]
  pull_request:
    # Le pipeline se déclenche aussi sur chaque Pull Request vers "main".
    # Cela permet de vérifier le code AVANT de le fusionner.
    branches: [main]

# ─── Variables d'environnement globales ───────────────────────────────────────
# On définit le nom de l'image Docker qui sera publiée sur GHCR.
# github.repository_owner = votre nom d'utilisateur GitHub.
env:
  IMAGE_NAME: ghcr.io/${{ github.repository_owner }}/nodeapp

# ─── Jobs ─────────────────────────────────────────────────────────────────────
# Un "job" est un ensemble d'étapes (steps) qui s'exécutent sur une même machine.
# Plusieurs jobs peuvent tourner en parallèle pour accélérer le pipeline.
jobs:

  # ══════════════════════════════════════════════════════════════════════════════
  # Job 1 : Build & Test
  # On installe les dépendances et on vérifie que l'application démarre correctement.
  # ══════════════════════════════════════════════════════════════════════════════
  build:
    name: Build & Test
    # On utilise une machine virtuelle Ubuntu fournie gratuitement par GitHub.
    runs-on: ubuntu-latest

    steps:
      # On commence toujours par récupérer le code source du dépôt.
      - uses: actions/checkout@v4

      # On installe Node.js version 20 sur la machine virtuelle.
      # "cache: npm" permet de mettre en cache node_modules entre les runs → plus rapide.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      # On installe les dépendances définies dans package-lock.json.
      - name: Installer les dépendances
        run: npm ci

      # On vérifie que l'application démarre bien et répond sur /health.
      # Si curl retourne une erreur, la commande exit 1 fait échouer le job.
      - name: Vérifier que l'app démarre
        run: |
          # On lance l'app en arrière-plan (&)
          node app.js &
          # On attend 2 secondes le temps que le serveur soit prêt
          sleep 2
          # On envoie une requête GET sur /health et on attend un code 200
          curl -sf http://localhost:3000/health || exit 1
          # On tue le processus Node.js (le %1 désigne le premier job en arrière-plan)
          kill %1

  # ══════════════════════════════════════════════════════════════════════════════
  # Job 2 : Lint Dockerfile avec Hadolint
  # On analyse le Dockerfile pour détecter les mauvaises pratiques de sécurité.
  # Hadolint vérifie par exemple qu'on n'utilise pas "latest" comme tag d'image,
  # qu'on n'exécute pas en root, etc.
  # ══════════════════════════════════════════════════════════════════════════════
  hadolint:
    name: Lint Dockerfile
    runs-on: ubuntu-latest
    # Ce job attend que le job "build" réussisse avant de démarrer.
    needs: build

    steps:
      - uses: actions/checkout@v4

      # On utilise l'action officielle Hadolint qui analyse notre Dockerfile.
      - uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: Dockerfile

  # ══════════════════════════════════════════════════════════════════════════════
  # Job 3 : Scan de l'image Docker avec Trivy
  # Trivy est un scanner de vulnérabilités. Il inspecte l'image Docker et compare
  # tous les paquets installés avec une base de données de CVE (failles connues).
  # Si une faille CRITICAL ou HIGH est trouvée, le pipeline échoue.
  # ══════════════════════════════════════════════════════════════════════════════
  trivy:
    name: Scan Trivy
    runs-on: ubuntu-latest
    needs: build

    steps:
      - uses: actions/checkout@v4

      # On construit l'image Docker localement (sans la pousser sur un registry).
      - name: Construire l'image Docker pour le scan
        run: docker build -t nodeapp:scan .

      # On lance le scan Trivy sur l'image construite.
      # "exit-code: '1'" fait échouer le pipeline si des vulnérabilités sont trouvées.
      # On ne bloque QUE sur CRITICAL et HIGH (pas les LOW/MEDIUM).
      - name: Scanner l'image avec Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: nodeapp:scan
          format: table          # Affichage en tableau dans les logs
          severity: CRITICAL,HIGH
          exit-code: '1'         # Le job échoue si des vulnérabilités sont détectées

  # ══════════════════════════════════════════════════════════════════════════════
  # Job 4 : Analyse statique du code avec CodeQL
  # CodeQL est l'outil de GitHub pour analyser le code source à la recherche
  # de failles de sécurité (injections, mauvaises pratiques cryptographiques, etc.).
  # Il comprend le flux des données dans le code et détecte les patterns dangereux.
  # ══════════════════════════════════════════════════════════════════════════════
  codeql:
    name: Analyse CodeQL
    runs-on: ubuntu-latest
    needs: build
    # CodeQL a besoin de permissions pour écrire les résultats dans l'onglet Security.
    permissions:
      security-events: write  # Permet d'écrire les alertes de sécurité
      actions: read           # Permet de lire les métadonnées du workflow
      contents: read          # Permet de lire le code source

    steps:
      - uses: actions/checkout@v4

      # On initialise CodeQL en lui indiquant le langage à analyser.
      - name: Initialiser CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: javascript   # On analyse du JavaScript (Node.js)

      # On lance l'analyse. CodeQL va parcourir tout le code source.
      - name: Lancer l'analyse CodeQL
        uses: github/codeql-action/analyze@v3

  # ══════════════════════════════════════════════════════════════════════════════
  # Job 5 : Publication de l'image sur GHCR (GitHub Container Registry)
  # Ce job ne s'exécute QUE si les 3 jobs de sécurité (hadolint, trivy, codeql)
  # ont tous réussi ET qu'on est sur la branche main.
  # C'est le "portail" : l'image n'est publiée que si elle est sûre.
  # ══════════════════════════════════════════════════════════════════════════════
  publish:
    name: Publier sur GHCR
    runs-on: ubuntu-latest
    # On attend que les 3 jobs de sécurité soient tous verts.
    needs: [hadolint, trivy, codeql]
    # Condition supplémentaire : on ne publie que sur la branche main (pas les PRs).
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      packages: write   # Nécessaire pour pousser une image sur GHCR

    steps:
      - uses: actions/checkout@v4

      # On se connecte à GHCR (GitHub Container Registry) avec le token GitHub.
      # GITHUB_TOKEN est automatiquement créé par GitHub pour chaque run.
      - name: Se connecter à GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}        # Nom d'utilisateur GitHub
          password: ${{ secrets.GITHUB_TOKEN }} # Token auto-généré par GitHub Actions

      # On génère automatiquement les tags et labels de l'image Docker.
      # sha-<commit> : identifie précisément la version du code dans l'image.
      # latest : toujours pointer vers la dernière version stable.
      - name: Générer les métadonnées de l'image
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=sha-    # ex : sha-a1b2c3d
            type=raw,value=latest   # tag "latest" toujours à jour

      # On construit l'image finale et on la pousse vers GHCR.
      # Elle sera disponible à l'adresse : ghcr.io/VOTRE_USERNAME/nodeapp:latest
      - name: Construire et pousser l'image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
